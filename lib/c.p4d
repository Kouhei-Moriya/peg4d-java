// PEG4d C Grammar
// ===============
//
// Based on grammar from ECMA-262, 5.1 Edition [1]. Generated parser builds a
// syntax tree compatible with Mozilla SpiderMonkey Parser API [2]. Properties
// and node types reflecting features not present in ECMA-262 are not included.
//
// Limitations:
//
//   * Non-BMP characters are completely ignored to avoid surrogate pair
//     handling.
//
// All the limitations could be resolved, but the costs would likely outweigh
// the benefits.
//
// Many thanks to inimino [3] for his grammar [4] which helped me to solve some
// problems (such as automatic semicolon insertion) and also served to double
// check that I converted the original grammar correctly.
//
// [1] http://www.ecma-international.org/publications/standards/Ecma-262.htm
// [2] https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
// [3] http://inimino.org/~inimino/blog/
// [4] http://boshi.inimino.org/3box/asof/1270029991384/PEG/ECMAScript_unified.peg
//

export
	= Statement
	/ Expression
	/ CInteger
	/ CFloat
	/ CString
	/ CChar

File
	= _ { @ExternalDeclaration #Source } EOT
	
Chunk
	= Expression
	/ Statement
	/ Type
	
_
	= (S / LONGCOMMENT / LINECOMMENT / PRAGMA)*
	
S
	= [ \n\r\t\u000B\u000C]
	
LONGCOMMENT
	= '/*' (!'*/' .)* '*/'
	
LINECOMMENT
	= '//' (!'\n' .)*
	
PRAGMA
	= '#' (!'\n' .)*

ATTRIBUTE
	= '__attribute__' !WCHAR _ '((' (!'))' .)* '))' _

DIGIT
	= [0-9]

WCHAR
	= [a-zA-Z0-9_]
	/ UCHAR

UCHAR
	= '\\u' HEX4
	/ '\\U' HEX4 HEX4

HEX4
	= HEX HEX HEX HEX

Name
	= { NAME #Name } _ 

NAME
	= !DIGIT !(KEYWORD !WCHAR) WCHAR+

KEYWORD
	= 'auto' / 'break' / 'case' / 'char' / 'const' / 'continue' / 'default' 
	/ 'double' / 'do' / 'else' / 'enum' / 'extern' / 'float' / 'for' 
	/ 'goto' / 'if' / 'int' / 'inline' / 'long' / 'register' / 'restrict' 
	/ 'return' / 'short' / 'signed' / 'sizeof' / 'static' / 'struct' 
	/ 'switch' / 'typedef' / 'union' / 'unsigned' / 'void' / 'volatile' 
	/ 'while' / '_Bool' / '_Complex' / '_Imaginary' / '_stdcall' 
	/ '__declspec' / '__attribute__' / '__asm'

INC     = '++' _
DEC     = '--' _
AND     = '&' !'&' _
STAR    = '*' !'=' _
PLUS    = '+' ![+=] _
MINUS   = '-' !('-' / [=>]) _
TILDA   = '~' _
BANG    = '!' !'=' _
VOID      = 'void'     !WCHAR
CHAR      = 'char'     !WCHAR
SHORT     = 'short'    !WCHAR
INT       = 'int'      !WCHAR
LONG      = 'long'     !WCHAR
FLOAT     = 'float'    !WCHAR
DOUBLE    = 'double'   !WCHAR
SIGNED    = 'signed'   !WCHAR
UNSIGNED  = 'unsigned' !WCHAR
BOOL      = '_Bool'    !WCHAR
COMPLEX   = '_Complex' !WCHAR
STRUCT    = 'struct'   !WCHAR
UNION     = 'union'    !WCHAR
LWING     = '{' _ ;
LBRK      = '[' _ ;
RBRK      = ']' _ ;
COMMA_	  = ',' _
ELLIPSIS	= '...' _
COLON	= ':' ![>] _
DIV	= '/' !'=' _
MOD	= '%' ![=>] _
LEFT	= '<<' !'=' _
RIGHT	= '>>' !'=' _
LE	= '<=' _
GE	= '>=' _
LT	= '<' ![=] _
GT	= '>' ![=] _
EQUEQU	= '==' _
BANGEQU	= '!=' _
HAT	= '^' ![=] _
OR	= '|' ![=] _
ANDAND	= '&&' _
OROR	= '||' _
QUERY	= '?' _
SEMI	= ';' _
RWING	= '}' _
PTR	= '->' _
ENUM	= 'enum' !WCHAR _
ASM	= '__asm' !WCHAR _
CASE	= 'case' !WCHAR _
DEFAULT	= 'default' !WCHAR _
IF	= 'if' !WCHAR _
ELSE	= 'else' !WCHAR _
SWITCH	= 'switch' !WCHAR _
WHILE	= 'while' !WCHAR _
DO	= 'do' !WCHAR _
FOR	= 'for' !WCHAR _
GOTO	= 'goto' !WCHAR _
CONTINUE	= 'continue' !WCHAR _
BREAK	= 'break' !WCHAR _
RETURN	= 'return' !WCHAR _
STAREQU	= '*=' _
DIVEQU	= '/=' _
MODEQU	= '%=' _
PLUSEQU	= '+=' _
MINUSEQU	= '-=' _
LEFTEQU	= '<<=' _
RIGHTEQU	= '>>=' _
ANDEQU	= '&=' _
HATEQU	= '^=' _
OREQU	= '|=' _
EQU	= '=' !'=' _
DOT	= '.' _
SIZEOF	= 'sizeof' !WCHAR _
TYPEDEF	= 'typedef' !WCHAR _
EXTERN	= 'extern' !WCHAR _
STATIC	= 'static' !WCHAR _
AUTO	= 'auto' !WCHAR _
REGISTER	= 'register' !WCHAR _
CONST	= 'const' !WCHAR _
RESTRICT	= 'restrict' !WCHAR _
VOLATILE	= 'volatile' !WCHAR _
DECLSPEC	= '__declspec' !WCHAR _
LPAR	= '(' _
RPAR	= ')' _
INLINE	= 'inline' !WCHAR _
STDCALL	= '_stdcall' !WCHAR _

EOT	= !.


ISHII_VERSION = ''

TopLevel
	= FunctionDefinition
	/ Declaration

FunctionDefinition
	= { @AnnotationList @Type @Name LPAR @FunctionParamList RPAR @Block #Function }

AnnotationList
	= { (@Annotation)*  #List } _

Annotation
	= EXTERN   { #KeyValue @{`extern` #Key } @{`true` #Value } } _
	/ STATIC   { #KeyValue @{`static` #Key } @{`true` #Value } } _
	/ AUTO     { #KeyValue @{`auto` #Key } @{`true` #Value } } _
	/ REGISTER { #KeyValue @{`register` #Key } @{`true` #Value } } _
	/ VOLATILE { #KeyValue @{`volatile` #Key } @{`true` #Value } } _
	/ DECLSPEC _ LPAR { #KeyValue @{`volatile` #Key } @(Name #Value) } _ RPAR _
	/ INLINE   { #KeyValue @{`inline` #Key } @{`true` #Value } } _
	/ STDCALL  { #KeyValue @{`stdcall` #Key } @{`true` #Value } } _

FunctionParamList
	= { ( Param (COMMA_ Param)+ )? #List } 

Param
	= { @Type _ @Name #Param} _
	
// Declaration
==============

Declaration
	= { @Annotation @Type @InitDecl (COMMA_ @InitDecl)* #Declaration } ATTRIBUTE? SEMI
	/ ISHII_VERSION DeclarationNoAttribute^ ((Assembler)^)? SEMI

InitDecl
	= { VarName (EQU @Initializer)? #Init } _

VarName
	= { STAR @VarName #Pointer } _
	/ Name

Initializer
	= AssignmentExpression
	/ LWING { (AddInitializerList)* COMMA_? #Initializer } RWING

AddInitializerList
	= (@Designation / @Initializer)? (COMMA_ (@Designation / @Initializer))*

Designation
	= { (@Designator)+ EQU @Initializer  #Designation }
	
Designator
	= LBRK ConstantExpression RBRK
	/ DOT Name


//Type
//====

Type
	= { CONST _ @TypeSuffix #TConst } _ / TypeSuffix 

TypeSuffix
	= PrimaryType {@ (STAR (POINTER_QUALIFIER)* #TPointer / LBRK (NAME / DIGIT* ) _ RBRK #TPointer / AddFuncType ) }*

POINTER_QUALIFIER
	= CONST / RESTRICT

AddFuncType
	= LPAR STAR @Name RPAR LPAR (@Type (_ NAME _)? (COMMA_ @Type (_ NAME _)? )* )? RPAR #Tfunc
	
PrimaryType
	= { STRUCT _ @Name #TStruct } _
	/ { UNION _ @Name  #TUnion } _
	/ { VOID #Tvoid } _
	/ { SIGNED_PREFIX? CHAR          #Tint } _
	/ { SIGNED_PREFIX? SHORT         #Tint } _
	/ { SIGNED_PREFIX? INT           #Tint } _
	/ { FLOAT         #Tfloat } _
	/ { DOUBLE        #Tfloat } _
	/ { LONG _ DOUBLE   #Tfloat } _
	/ { SIGNED_PREFIX?ã€€LONG (_ LONG)? (_ INT)? #Tint } _
	/ { SIGNED `signed int` #Tint } _
	/ { UNSIGNED `unsigned int` #Tint } _
	/ { BOOL #Tbool } _
	/ { COMPLEX #Tcomplex } _
	/ { NAME_T #Ttype } _
	/ { NAME   #Name } _

SIGNED_PREFIX
	= (SIGNED _ / UNSIGNED _ )

NAME_T
	= !DIGIT (!('_t' !WCHAR)  WCHAR )+ '_t' !WCHAR



// Block, Statement
===================

Block
	= { LWING (@(Declaration / Statement))* RWING #Block }

Statement
	= Block
	/ { IF     LPAR @Expression RPAR @Statement (ELSE @Statement)? #If }
	/ { SWITCH LPAR @Expression RPAR @Statement #Switch }
	/ { WHILE  LPAR @Expression RPAR @Statement #While }
	/ { DO @Statement WHILE LPAR @Expression RPAR SEMI #DoWhile }
	/ { FOR LPAR (@Expression)? SEMI (@Expression^) SEMI (@Expression)? RPAR @Statement #For }
	/ { FOR LPAR @Declaration (@Expression)? SEMI (@Expression)? RPAR @Statement #For }
	/ { GOTO Name #Goto } SEMI
	/ { CONTINUE #Continue } SEMI 
	/ { BREAK #Break } SEMI 
	/ { RETURN (@Expression)? #Return } SEMI 
	/ { @Name COLON @Statement #LabelBlock }
	/ Expression SEMI
	/ { #Empty } SEMI

LabeledStatement
	= { CASE @ConstantExpression COLON @Statement #SwitchCase }
	/ { DEFAULT COLON @Statement #SwitchDefault }
	;

//Expression
//==========

Expression
	= AssignmentExpression {@ COMMA_ @AssignmentExpression #Expression }*

AssignmentExpression
	= { @UnaryExpression AddAssignmentOperator @AssignmentExpression }
	/ ConditionalExpression

AddAssignmentOperator
	= EQU        #Assign
	/ STAREQU    #AssignMul
	/ DIVEQU     #AssignDiv
	/ MODEQU     #AssignMod
	/ PLUSEQU    #AssignAdd
	/ MINUSEQU   #AssignSub
	/ LEFTEQU    #AssignLeftShift
	/ RIGHTEQU   #AssignRightShift
	/ ANDEQU     #AssignBitwiseAnd
	/ HATEQU     #AssignBitwiseXOr 
	/ OREQU      #AssignBitwiseOr

ConstantExpression
	= ConditionalExpression
	
ConditionalExpression
	= LogicalORExpression {@ QUERY  @Expression COLON @LogicalORExpression #Trinary }*

LogicalORExpression
	= LogicalANDExpression {@ OROR @LogicalANDExpression #Or }*

LogicalANDExpression
	= InclusiveORExpression {@ ANDAND @InclusiveORExpression #And }*

InclusiveORExpression
	= ExclusiveORExpression {@ OR @ExclusiveORExpression #BitwiseOr }*

ExclusiveORExpression
	= ANDExpression {@ HAT @ANDExpression #BitwiseXor }*

ANDExpression
	= EqualityExpression {@ AND @EqualityExpression #BitwiseAnd }*

EqualityExpression
	= RelationalExpression {@ ( EQUEQU #Equals / BANGEQU #NotEquals ) @RelationalExpression }*
	
RelationalExpression
	= ShiftExpression {@ ( LE #LessThanEquals / GE #GreaterThanEquals / LT #LessThan / GT #GreaterThan ) @ShiftExpression }*
	
ShiftExpression
	= AdditiveExpression {@ ( LEFT #LeftShift / RIGHT #RightShift ) @AdditiveExpression }*
	
AdditiveExpression
	= MultiplicativeExpression {@ ( PLUS #Add / MINUS #Sub ) @MultiplicativeExpression }*
	
MultiplicativeExpression
	= CastExpression {@ ( STAR #Mul / DIV #Div / MOD #Mod ) @CastExpression }*


UnaryExpression
	= PostfixExpression
	/ { INC    UnaryExpression #PrefixInc }
	/ { DEC    UnaryExpression #PrefixDec }
	/ { AND    CastExpression #Address }
	/ { STAR   CastExpression #Star }
	/ { PLUS   CastExpression #Plus }
	/ { MINUS  CastExpression #Minus }
	/ { TILDA  CastExpression #Compl }
	/ { BANG   CastExpression #Not }
	/ { SIZEOF  ( @UnaryExpression / LPAR @TypeName RPAR ) #SizeOf }

CastExpression
	= { LPAR @TypeName RPAR @CastExpression #Cast }
	/ UnaryExpression
	

PostfixExpression
	= ( PrimaryExpression / ISHII_VERSION LPAR TypeName RPAR LWING { (AddInitializerList)* COMMA_? #Initializer } RWING ) 
	{@ (AddFunctionCall / AddIndex  / DOT @Name #Field / PTR @Name #PointerField / INC #Inc / DEC #Dec) }*

AddFunctionCall
	= LPAR @{ AddArgumentExpressionList? #List} RPAR #Apply

AddArgumentExpressionList
	= (@AssignmentExpression (COMMA_ @AssignmentExpression)*)

AddIndex
	= LBRK @Expression RBRK #Index

PrimaryExpression
	= Constant
	/ CString
	/ LPAR Expression RPAR
	/ Name
	
//Literal
//=======

Constant
	= CFloat
	/ CInteger
	/ CChar

CFloat
	= { ( DECIMAL_FLOAT / HEX_FLOAT )  #Float } FLOAT_SUFFIX? _

DECIMAL_FLOAT
	= FRACTION EXPONENT?
	/ DIGIT+ EXPONENT

FRACTION
	= DIGIT* '.' DIGIT+
	/ DIGIT+ '.'

EXPONENT
	= [eE] [+\-]? DIGIT+

HEX_FLOAT
	= HEX_PREFIX HEX_FRACTION BINARY_EXPONENT?
	/ HEX_PREFIX HEX+ BINARY_EXPONENT

HEX_PREFIX
	= '0' [xX]

HEX_FRACTION
	= HEX* '.' HEX+
	/ HEX+ '.'

BINARY_EXPONENT
	= [pP] [+\-]? DIGIT+

FLOAT_SUFFIX
	= [flFL]

CInteger
	= { ( DECIMAL / HEXICAL / OCTAL ) #Integer } INT_SUFFIX? _

DECIMAL
	= [1-9] DIGIT*

HEXICAL
	= HEX_PREFIX HEX+

OCTAL
	= '0' [0-7]*

INT_SUFFIX
	= [uU] LONG_SUFFIX?
	/ LONG_SUFFIX [uU]?

LONG_SUFFIX
	= 'll'
	/ 'LL'
	/ [lL]


	
CString
	=  'L'? ('"' { STRING_CONTENT* #String } '"' _)+

CChar
	= 'L'? "'" { CHAR_CONTENT* #Character } "'" _

STRING_CONTENT
	= ESCAPE
	/ ![\"\n\\] .


CHAR_CONTENT
	= ESCAPE
	/ !['\n\\] .

ESCAPE
	= SIMPLE_ESCAPE
	/ OCTAL_ESCAPE
	/ HEX_ESCAPE
	/ UCHAR
	;

SIMPLE_ESCAPE
	= '\\' ['\"?\\abfnrtv]
	
OCTAL_ESCAPE
	= '\\' [0-7] [0-7]? [0-7]?
	
HEX_ESCAPE
	= '\\x' HEX+
	

	
	
// ==========================================================================

ExternalDeclaration
	= FunctionDefinitionOrig
	/ DeclarationOrig
	
FunctionDefinitionOrig
	= { DeclarationSpecifiers^3 Declarator^0 (DeclarationList^1)? Block^2 #Function }

DeclarationOrig
	= DeclarationNoAttribute^ ((Assembler)^)? SEMI

DeclarationList
	= Declaration+

DeclarationNoAttribute
	= DeclarationSpecifiers^ (InitDeclaratorList^)?
	;
InitDeclaratorList
	= InitDeclarator^ (COMMA_ InitDeclarator^)*
	;
InitDeclarator
	= { (Pointer^)? DirectDeclarator^ (EQU Initializer^)? #assign }
	;
Assembler
	= ASM LPAR (CString (COMMA_ CString)*)? RPAR
	;

DeclarationSpecifiers
	= (StorageClassSpecifier / TypeQualifier / FunctionSpecifier)* 
	   TypedefName (StorageClassSpecifier / TypeQualifier / FunctionSpecifier)*
	/ (StorageClassSpecifier / TypeSpecifier / TypeQualifier / FunctionSpecifier)+
	
StorageClassSpecifier
	= TYPEDEF / EXTERN / STATIC / AUTO / REGISTER

TypeQualifier
	= CONST
	/ RESTRICT
	/ VOLATILE
	/ DECLSPEC LPAR Name RPAR

FunctionSpecifier
	= INLINE
	/ STDCALL

TypeName
	= { SpecifierQualifierList^ (AbstractDeclarator^)? #c.typename }

SpecifierQualifierList
	= (TypeQualifier* TypedefName TypeQualifier*)^
	/ ((TypeSpecifier / TypeQualifier)^)+
	
TypedefName
	= { Name^ #c.typedefname }
	;
	
TypeSpecifier
	= { VOID #Tvoid }
	/ { CHAR #Tchar }
	/ { SHORT #Tshort }
	/ { INT #Tint }
	/ { LONG #Tlong }
	/ { FLOAT #Tfloat }
	/ { DOUBLE #Tdouble }
	/ { SIGNED #Tsigned }
	/ { UNSIGNED #Tunsigned }
	/ { BOOL #Tbool }
	/ { COMPLEX #Tcomplex }
	/ { StructOrUnionSpecifier #Tstructorunion }
	/ { EnumSpecifier #Tenum }

StructOrUnionSpecifier
	= StructOrUnion^ ( (Name^)? LWING (StructDeclaration^)+ RWING / Name^ )

StructOrUnion
	= { STRUCT #c.struct }
	/ { UNION #c.union }

StructDeclaration
	= { SpecifierQualifierList StructDeclaratorList^ SEMI #c.structdeclaration }

StructDeclaratorList
	= { StructDeclarator (COMMA_ StructDeclarator)* #c.structdeclaratorlist }

StructDeclarator
	= (Declarator^)? COLON ConstantExpression^
	/ Declarator^
	;
	
Declarator
	= (Pointer^)? DirectDeclarator^

Pointer
	= { (STAR (TypeQualifier^)*)+ #c.pointer }

DirectDeclarator
	= ( Name^ / LPAR Declarator^ RPAR ) ({ LBRK (TypeQualifier^)* (AssignmentExpression^)? RBRK #arraysize } / LBRK STATIC^ (TypeQualifier^)* AssignmentExpression^ RBRK / LBRK (TypeQualifier^)+ STATIC^ AssignmentExpression^ RBRK / LBRK (TypeQualifier^)* STAR^ RBRK / LPAR ParameterTypeList^ RPAR / LPAR (NameList^)? RPAR)*
	;
ParameterTypeList
	= ParameterList^ (COMMA_ ELLIPSIS)?
	;
ParameterList
	= ParameterDeclaration {@ COMMA_ ParameterDeclaration^ #param }*
	;
ParameterDeclaration
	= DeclarationSpecifiers {@ (Declarator / AbstractDeclarator)^ #c.parameterdeclaration }?
	;
AbstractDeclarator
	= Pointer? DirectAbstractDeclarator
	/ Pointer
	;
DirectAbstractDeclarator
	= ( LPAR AbstractDeclarator RPAR / LBRK (AssignmentExpression / STAR)? RBRK / LPAR ParameterTypeList? RPAR ) (LBRK (AssignmentExpression / STAR)? RBRK / LPAR ParameterTypeList? RPAR)*
	;

NameList
	= { Name^ (COMMA_ Name^)* #c.identifierlist }
	;

EnumSpecifier
	= ENUM ( (Name^)? LWING EnumeratorList^ COMMA_? RWING / Name^ )
	;
EnumeratorList
	= Enumerator {@ (COMMA_ Enumerator^)* #c.enumeratorlist }
	;
Enumerator
	= EnumerationConstant (EQU ConstantExpression)?
	;

EnumerationConstant
	= Name
	;
	
	

	